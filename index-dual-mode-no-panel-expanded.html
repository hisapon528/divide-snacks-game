<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>おかし分けゲーム（①ドラッグ／②かこい｜学びパネルなし・拡大）</title>
<style>
  :root{
    --bg:#f8fafc; --ink:#0f172a; --muted:#64748b; --good:#16a34a; --bad:#ef4444; --card:#fff; --grid:#e5e7eb; --accent:#2563eb;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "BIZ UDPGothic","Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; color:var(--ink); background:#f8fafc;}
  .wrap{max-width:1100px; margin:0 auto; padding:16px}
  .card{background:#fff; border-radius:18px; box-shadow:0 8px 24px rgba(0,0,0,.06); padding:16px;}
  h1{margin:4px 0 10px; font-size:clamp(18px,2.6vw,28px)}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .pill{border:1px solid var(--grid); padding:6px 10px; border-radius:999px; background:#fff; display:flex; align-items:center; gap:8px}
  .pill label{display:flex; gap:4px; align-items:center}
  button{border:none; border-radius:12px; padding:9px 14px; background:#0f172a; color:#fff; cursor:pointer}
  button.ghost{background:#fff; color:#000; border:1px solid var(--grid)}
  button.good{background:var(--good)} button.bad{background:var(--bad)}
  button:disabled{opacity:.5; cursor:not-allowed}
  .area{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:10px}
  .board{position:relative; background:#fff; border:1px dashed var(--grid); border-radius:14px; padding:12px}
  .titleRow{display:flex; justify-content:space-between; align-items:center; margin:0 4px 6px}
  .mini{font-size:13px; color:#64748b}
  /* ステージを横幅いっぱいに拡大（最大 860px） */
  .stage{ position:relative; width:100%; max-width:860px; margin:0 auto; aspect-ratio: 4/3; background:#fff; border-radius:12px; border:1px solid var(--grid); overflow:hidden;}
  /* おかしを少し小さめ（前回 44px を継続） */
  .snack{ position:absolute; width:44px; height:44px; border-radius:50%; 
          background:radial-gradient(circle at 35% 35%, #6b7280 8px, #111827 9px, #333 10px, #111 12px, #2b2b2b 18px, #1b1b1b 22px);
          box-shadow: inset 0 0 0 2px #0a0a0a, 0 2px 5px rgba(0,0,0,.22);
          touch-action:none;
  }
  .overlay{ position:absolute; inset:0; pointer-events:none }
  .overlay svg{ width:100%; height:100%}
  .mark{ fill: rgba(37,99,235,.10); stroke:#2563eb; stroke-width:3 }
  .countLabel{ font-weight:700; fill:#1e40af }
  /* トレーの高さをさらに拡大（55%） */
  .trays{ position:absolute; left:0; right:0; bottom:0; height:55%; display:flex; gap:14px; padding:14px; pointer-events:none}
  .tray{ flex:1; border:2px dashed #e5e7eb; border-radius:14px; background:#f8fafc; position:relative; pointer-events:auto; min-height: 100%}
  .tray::before{ content: attr(data-label); position:absolute; left:10px; top:8px; font-size:12px; color:#64748b}
  .tray.highlight{ border-color: #2563eb; box-shadow: 0 0 0 3px rgba(37,99,235,.15) inset}
  .msg{margin-top:8px; text-align:center; font-weight:800; font-size:18px}
  .msg.good{ color:#16a34a} .msg.bad{ color:#ef4444}
  .counts{display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:10px}
  .tag{background:#eef2ff; color:#1e3a8a; padding:6px 10px; border-radius:999px; font-weight:700}
  .status{ display:flex; gap:10px; justify-content:center; align-items:center; margin-top:6px; font-size:14px; color:#475569 }
  .status .mini{ font-size:13px }
  .hide{display:none !important}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>おかし分けゲーム（①ドラッグ／②かこい）</h1>
    <div class="toolbar">
      <span class="pill">モード：
        <label><input type="radio" name="mode" value="drag" checked> ①ドラッグ</label>
        <label><input type="radio" name="mode" value="enclose"> ②かこい</label>
      </span>
      <span id="peopleWrap" class="pill">人数：
        <select id="peopleSelect">
          <option value="2" selected>2人</option>
          <option value="4">4人</option>
        </select>
      </span>
      <span class="pill">おかし：
        <select id="numSelect">
          <option value="8" selected>8こ</option>
          <option value="12">12こ</option>
          <option value="16">16こ</option>
        </select>
      </span>
      <button id="drawBtn" class="hide">分ける（しかくをかく）</button>
      <button id="undoBtn" class="ghost" disabled>やりなおし</button>
      <button id="clearBtn" class="ghost">ぜんぶけす</button>
      <button id="checkBtn" class="good">こたえあわせ</button>
      <button id="randomBtn" class="ghost">つぎのもんだい</button>
    </div>

    <div class="area">
      <section class="board">
        <div class="titleRow">
          <strong>おかしの図</strong>
          <span class="mini" id="modeHelp">ドラッグで下のトレーに入れます（①ドラッグ）</span>
        </div>
        <div id="stage" class="stage" aria-label="おかしのステージ">
          <div id="snacks"></div>
          <div id="trays" class="trays"></div>
          <div class="overlay" id="overlay">
            <svg id="svg"></svg>
          </div>
        </div>
        <div class="counts" id="counts"></div>
        <!-- 学びのめあてパネルを廃止したので、合計と分数ヒントはここで表示 -->
        <div class="status">
          <span>ぜんぶで <strong id="totalLabel">8</strong> こ。</span>
          <span id="fractionLine" class="mini"></span>
        </div>
        <div class="msg" id="message" aria-live="polite"></div>
      </section>
    </div>
  </div>
</div>

<script>
(() => {
  const TRAY_H = 0.55; // ★トレーの高さ（ステージ比）
  const snackSize = 44; // おかしサイズ
  const gridCols = 4;

  const stage = document.getElementById('stage');
  const snacksWrap = document.getElementById('snacks');
  const traysWrap = document.getElementById('trays');
  const svg = document.getElementById('svg');
  const numSel = document.getElementById('numSelect');
  const peopleSel = document.getElementById('peopleSelect');
  const drawBtn = document.getElementById('drawBtn');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const checkBtn = document.getElementById('checkBtn');
  const randomBtn = document.getElementById('randomBtn');
  const countsEl = document.getElementById('counts');
  const msg = document.getElementById('message');
  const totalLabel = document.getElementById('totalLabel');
  const fractionLine = document.getElementById('fractionLine');
  const modeHelp = document.getElementById('modeHelp');
  const modeRadios = [...document.querySelectorAll('input[name=\"mode\"]')];

  let snacks = [];   // {homeX,homeY, el}
  let assign = [];   // snack -> tray index (-1 for none)
  let rects = [];    // {x,y,w,h,r,node}
  let drawMode = false; // for enclose
  let drawing = null;
  let dragState = null; // {index, offsetX,offsetY}
  const undoStack = []; // [{type:'addRect'|'moveSnack', data:...}]

  // ===== レイアウト（上段グリッド／下段トレー） =====
  function layoutSnacks(total){
    snacksWrap.innerHTML = '';
    snacks = []; assign = new Array(total).fill(-1);
    const rect = stage.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const gridH = h * (1 - TRAY_H);
    const colGap = (w - snackSize*gridCols) / (gridCols+1);
    const rowCount = Math.ceil(total / gridCols);
    const rowGap = (gridH - snackSize*rowCount) / (rowCount+1);
    let idx = 0;
    for(let r=0;r<rowCount;r++){
      for(let c=0;c<gridCols;c++){
        if(idx >= total) break;
        const x = colGap*(c+1) + snackSize*c;
        const y = rowGap*(r+1) + snackSize*r;
        const d = document.createElement('div');
        d.className='snack';
        d.style.width = snackSize+'px';
        d.style.height = snackSize+'px';
        d.dataset.index = idx;
        d.style.left = x+'px'; d.style.top = y+'px';
        snacksWrap.appendChild(d);
        snacks.push({homeX:x, homeY:y, el: d});
        idx++;
      }
    }
    bindSnackEvents();
  }

  function buildTrays(n){
    traysWrap.innerHTML='';
    for(let i=0;i<n;i++){
      const t = document.createElement('div');
      t.className='tray';
      t.dataset.index = i;
      t.setAttribute('data-label', `トレー${i+1}`);
      traysWrap.appendChild(t);
    }
  }
  function layoutTrayContents(){
    const trays = [...document.querySelectorAll('.tray')];
    const perTray = trays.map(()=>[]);
    assign.forEach((ti, si)=>{ if(ti>=0) perTray[ti].push(si); });
    trays.forEach((tray, i)=>{
      perTray[i].forEach((si, k)=>{
        const s = snacks[si];
        if(s.el.parentNode !== tray) tray.appendChild(s.el);
        tray.style.position='relative';
        const pad = 12;
        const cols = Math.max(1, Math.floor((tray.clientWidth - pad*2) / (snackSize+8)));
        const col = k % cols;
        const row = Math.floor(k / cols);
        const x = pad + col*(snackSize+8);
        const y = 26 + row*(snackSize+8); // ラベル分の余白
        s.el.style.left = x+'px'; s.el.style.top = y+'px';
        s.el.style.width = snackSize+'px'; s.el.style.height = snackSize+'px';
      });
    });
    // 未割り当ては上段へ戻す
    assign.forEach((ti, si)=>{
      if(ti === -1){
        const s = snacks[si];
        if(s.el.parentNode !== snacksWrap) snacksWrap.appendChild(s.el);
        s.el.style.left = s.homeX+'px'; s.el.style.top = s.homeY+'px';
        s.el.style.width = snackSize+'px'; s.el.style.height = snackSize+'px';
      }
    });
  }

  // ===== ドラッグ（①） =====
  function bindSnackEvents(){
    snacks.forEach((s, si)=>{
      s.el.onmousedown = (e)=>{
        if(currentMode()!=='drag') return;
        e.preventDefault();
        const rect = (assign[si]>=0 ? s.el.parentElement : stage).getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const offsetX = x - parseFloat(s.el.style.left);
        const offsetY = y - parseFloat(s.el.style.top);
        dragState = {index: si, offsetX, offsetY};
        s.el.style.transition = 'none';
        highlightTray(null);
      };
      s.el.ontouchstart = (e)=>{
        if(currentMode()!=='drag') return;
        const t = e.touches[0];
        const rect = (assign[si]>=0 ? s.el.parentElement : stage).getBoundingClientRect();
        const x = t.clientX - rect.left, y = t.clientY - rect.top;
        const offsetX = x - parseFloat(s.el.style.left);
        const offsetY = y - parseFloat(s.el.style.top);
        dragState = {index: si, offsetX, offsetY};
        s.el.style.transition = 'none';
        highlightTray(null);
        e.preventDefault();
      };
    });
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp, {passive:false});
  }

  function onMove(e){
    if(!dragState || currentMode()!=='drag') return;
    const isTouch = e.touches && e.touches[0];
    const cx = isTouch ? e.touches[0].clientX : e.clientX;
    const cy = isTouch ? e.touches[0].clientY : e.clientY;
    const s = snacks[dragState.index];
    const parent = (assign[dragState.index]>=0 ? s.el.parentElement : stage);
    const rect = parent.getBoundingClientRect();
    const x = cx - rect.left - dragState.offsetX;
    const y = cy - rect.top - dragState.offsetY;
    s.el.style.left = x+'px'; s.el.style.top = y+'px';
    const trays = [...document.querySelectorAll('.tray')];
    let over = -1;
    trays.forEach((t,i)=>{
      const r = t.getBoundingClientRect();
      if(cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom) over=i;
    });
    highlightTray(over);
    if(isTouch) e.preventDefault();
  }

  function onUp(e){
    if(!dragState || currentMode()!=='drag') return;
    const isTouch = e.changedTouches && e.changedTouches[0];
    const cx = isTouch ? e.changedTouches[0].clientX : e.clientX;
    const cy = isTouch ? e.changedTouches[0].clientY : e.clientY;
    const sIndex = dragState.index;
    const prev = assign[sIndex];
    const trays = [...document.querySelectorAll('.tray')];
    let target = -1;
    trays.forEach((t,i)=>{
      const r = t.getBoundingClientRect();
      if(cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom) target=i;
    });
    assign[sIndex] = target;
    layoutTrayContents();
    updateCounts();
    updateFractionHint();
    undoStack.push({type:'moveSnack', data:{si:sIndex, from:prev, to:target}});
    setUndoState();
    highlightTray(null);
    dragState = null;
  }

  function highlightTray(index){
    [...document.querySelectorAll('.tray')].forEach((t,i)=>{
      t.classList.toggle('highlight', i===index);
    });
  }

  // ===== かこい（②） =====
  function clearRects(){
    rects = [];
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    updateCounts();
    msg.textContent = ''; msg.className = 'msg';
    updateFractionHint();
  }
  function startDraw(clientX, clientY){
    const box = stage.getBoundingClientRect();
    const x = clientX - box.left, y = clientY - box.top;
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('class','mark');
    r.setAttribute('x', x); r.setAttribute('y', y); r.setAttribute('width', 1); r.setAttribute('height', 1);
    r.setAttribute('rx', 16); r.setAttribute('ry', 16);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('class','countLabel');
    t.setAttribute('x', x+0.5); t.setAttribute('y', y+0.5);
    t.setAttribute('text-anchor','middle'); t.setAttribute('dy','.35em');
    t.textContent='';
    g.appendChild(r); g.appendChild(t); svg.appendChild(g);
    drawing = {startX:x, startY:y, node:g};
  }
  function moveDraw(clientX, clientY){
    if(!drawing) return;
    const box = stage.getBoundingClientRect();
    const x = clientX - box.left, y = clientY - box.top;
    const x1 = Math.min(drawing.startX, x), y1 = Math.min(drawing.startY, y);
    const w = Math.abs(x - drawing.startX), h = Math.abs(y - drawing.startY);
    const rr = drawing.node.querySelector('rect');
    const t = drawing.node.querySelector('text');
    rr.setAttribute('x', x1); rr.setAttribute('y', y1); rr.setAttribute('width', w); rr.setAttribute('height', h);
    t.setAttribute('x', x1 + w/2); t.setAttribute('y', y1 + h/2);
  }
  function pointInRoundRect(px, py, rect){
    const {x,y,w,h,r} = rect;
    if (w<=0 || h<=0) return false;
    const rx = Math.min(r, w/2), ry = Math.min(r, h/2);
    if (px >= x+rx && px <= x+w-rx && py >= y && py <= y+h) return true;
    if (py >= y+ry && py <= y+h-ry && px >= x && px <= x+w) return true;
    const c1 = {cx:x+rx, cy:y+ry};
    const c2 = {cx:x+w-rx, cy:y+ry};
    const c3 = {cx:x+rx, cy:y+h-ry};
    const c4 = {cx:x+w-rx, cy:y+h-ry};
    const inCircle = (cx,cy)=> (px-cx)*(px-cx) + (py-cy)*(py-cy) <= Math.min(rx,ry)*Math.min(rx,ry);
    if(px < x+rx && py < y+ry) return inCircle(c1.cx,c1.cy);
    if(px > x+w-rx && py < y+ry) return inCircle(c2.cx,c2.cy);
    if(px < x+rx && py > y+h-ry) return inCircle(c3.cx,c3.cy);
    if(px > x+w-rx && py > y+h-ry) return inCircle(c4.cx,c4.cy);
    return false;
  }
  function countSnacksInRect(rect){
    let cnt = 0;
    snacks.forEach(s=>{
      const rectStage = stage.getBoundingClientRect();
      const elRect = s.el.getBoundingClientRect();
      const cx = elRect.left - rectStage.left + s.el.offsetWidth/2;
      const cy = elRect.top - rectStage.top + s.el.offsetHeight/2;
      if(pointInRoundRect(cx, cy, rect)) cnt++;
    });
    return cnt;
  }
  function endDraw(){
    if(!drawing) return;
    const rr = drawing.node.querySelector('rect');
    const x = parseFloat(rr.getAttribute('x'));
    const y = parseFloat(rr.getAttribute('y'));
    const w = Math.max(12, parseFloat(rr.getAttribute('width')));
    const h = Math.max(12, parseFloat(rr.getAttribute('height')));
    const r = parseFloat(rr.getAttribute('rx')) || 16;
    rr.setAttribute('width', w); rr.setAttribute('height', h);
    const temp = {x,y,w,h,r,node:drawing.node};
    const inside = countSnacksInRect(temp);
    if(inside === 0){
      if (temp.node && temp.node.parentNode) temp.node.parentNode.removeChild(temp.node);
      msg.textContent = '中におかしがない しかくは作りません。'; msg.className = 'msg';
    }else{
      rects.push(temp);
      undoStack.push({type:'addRect', data:{node:temp.node}});
    }
    drawing = null;
    updateCounts();
    updateFractionHint();
    setUndoState();
  }

  function computeAssignmentsEnclose(){
    const rectStage = stage.getBoundingClientRect();
    const belong = snacks.map(()=> -1);
    let overlap = false;
    rects.forEach((rc, ri)=>{
      snacks.forEach((s, si)=>{
        const elRect = s.el.getBoundingClientRect();
        const cx = elRect.left - rectStage.left + s.el.offsetWidth/2;
        const cy = elRect.top - rectStage.top + s.el.offsetHeight/2;
        if(pointInRoundRect(cx, cy, rc)){
          if(belong[si] !== -1) overlap = true;
          belong[si] = ri;
        }
      });
    });
    return {belong, overlap};
  }

  // ===== 共通UI =====
  function currentMode(){ return modeRadios.find(r=>r.checked).value; }
  function setUndoState(){ undoBtn.disabled = undoStack.length === 0; }

  function updateCounts(){
    countsEl.innerHTML = '';
    if(currentMode()==='drag'){
      const n = parseInt(peopleSel.value,10);
      const per = new Array(n).fill(0);
      assign.forEach(ti => { if(ti>=0) per[ti]++; });
      per.forEach((n,i)=>{
        const tag = document.createElement('div');
        tag.className='tag'; tag.textContent = `トレー${i+1}：${n}こ`; countsEl.appendChild(tag);
      });
      const unassigned = assign.filter(v=>v===-1).length;
      const tag = document.createElement('div');
      tag.className='tag'; tag.textContent = `のこり：${unassigned}こ`; countsEl.appendChild(tag);
      msg.textContent = ''; msg.className='msg';
    }else{
      const {belong, overlap} = computeAssignmentsEnclose();
      const per = rects.map(()=>0);
      belong.forEach(ri => { if(ri>=0) per[ri]++; });
      rects.forEach((rc, i)=>{
        const t = rc.node.querySelector('text');
        t.textContent = per[i] ? per[i]+'こ' : '';
      });
      per.forEach((n,i)=>{
        const tag = document.createElement('div');
        tag.className='tag'; tag.textContent = `かこい${i+1}：${n}こ`; countsEl.appendChild(tag);
      });
      const unassigned = belong.filter(v=>v===-1).length;
      const tag = document.createElement('div');
      tag.className='tag'; tag.textContent = `のこり：${unassigned}こ`; countsEl.appendChild(tag);
      msg.textContent = overlap ? '同じおかしを分けています（重なり）' : msg.textContent;
      msg.className = overlap ? 'msg bad' : msg.className;
    }
  }

  function checkAnswer(){
    const total = snacks.length;
    if(currentMode()==='drag'){
      const n = parseInt(peopleSel.value,10);
      const per = new Array(n).fill(0);
      assign.forEach(ti => { if(ti>=0) per[ti]++; });
      const unassigned = assign.filter(v=>v===-1).length;
      if(unassigned>0){ msg.textContent='ぜんぶのおかしをトレーに入れよう。'; msg.className='msg bad'; return; }
      const same = per.every(v=>v===per[0]);
      if(!same){ msg.textContent='どのトレーも 同じ数に なるように分けよう。'; msg.className='msg bad'; return; }
      msg.textContent = `せいかい！ 人数：${n}人 ／ 1人分：${per[0]}こ`; msg.className='msg good';
      if([2,4].includes(n)) fractionLine.textContent = `（${total}この 1/${n} は ${per[0]}こ）`; else fractionLine.textContent = '';
    }else{
      if(rects.length === 0){ msg.textContent = 'しかくをかいて 人数をきめよう。'; msg.className='msg bad'; return; }
      const {belong, overlap} = computeAssignmentsEnclose();
      if(overlap){ msg.textContent = '同じおかしが 2つのしかくに入っています。'; msg.className='msg bad'; return; }
      const perCounts = rects.map(()=>0);
      belong.forEach(ri => { if(ri>=0) perCounts[ri]++; });
      const unassigned = belong.filter(v=>v===-1).length;
      if(unassigned>0){ msg.textContent='ぜんぶのおかしが 分けられていません。'; msg.className='msg bad'; return; }
      const first = perCounts[0];
      const allEqual = perCounts.every(n => n === first);
      if(!allEqual){ msg.textContent='どのかこいも 同じ数に なるように分けよう。'; msg.className='msg bad'; return; }
      msg.textContent = `せいかい！ 人数：${rects.length}人 ／ 1人分：${first}こ`; msg.className='msg good';
      if([2,4].includes(rects.length)) fractionLine.textContent = `（${total}この 1/${rects.length} は ${first}こ）`; else fractionLine.textContent='';
    }
  }

  function updateFractionHint(){
    const total = snacks.length; totalLabel.textContent = total;
    if(currentMode()==='drag'){
      const n = parseInt(peopleSel.value,10);
      if([2,4].includes(n) && Number.isInteger(total/n)){
        fractionLine.textContent = `ヒント： ${total}この 1/${n} は ${total/n}こ`;
      }else{ fractionLine.textContent=''; }
    }else{
      if([2,4].includes(rects.length) && Number.isInteger(total/rects.length)){
        fractionLine.textContent = `ヒント： ${total}この 1/${rects.length} は ${total/rects.length}こ`;
      }else{ fractionLine.textContent=''; }
    }
  }

  // ===== コントロール =====
  modeRadios.forEach(r=> r.addEventListener('change', onModeChange));
  function onModeChange(){
    const m = currentMode();
    const enclose = (m==='enclose');
    drawBtn.classList.toggle('hide', !enclose);
    peopleSel.parentElement.classList.toggle('hide', enclose);
    traysWrap.style.display = enclose ? 'none' : 'flex';
    modeHelp.textContent = enclose ? 'ドラッグして角丸のしかくをかきます（②かこい）' : 'ドラッグで下のトレーに入れます（①ドラッグ）';
    msg.textContent=''; msg.className='msg';
    if(enclose){
      assign.fill(-1); layoutTrayContents(); updateCounts(); updateFractionHint();
    }else{
      clearRects(); updateCounts(); updateFractionHint();
    }
  }

  drawBtn.addEventListener('click', ()=>{
    drawMode = !drawMode;
    drawBtn.textContent = drawMode ? '分ける（描画中）' : '分ける（しかくをかく）';
    drawBtn.classList.toggle('ghost', !drawMode);
  });
  undoBtn.addEventListener('click', ()=>{
    if(undoStack.length===0) return;
    const act = undoStack.pop();
    if(act.type==='addRect'){
      const node = act.data.node;
      if(node && node.parentNode) node.parentNode.removeChild(node);
      rects.pop();
      updateCounts(); updateFractionHint();
    }else if(act.type==='moveSnack'){
      const {si, from} = act.data;
      assign[si] = from;
      layoutTrayContents(); updateCounts(); updateFractionHint();
    }
    setUndoState();
  });
  clearBtn.addEventListener('click', ()=>{
    if(currentMode()==='drag'){
      for(let i=0;i<assign.length;i++) assign[i] = -1;
      layoutTrayContents(); updateCounts(); updateFractionHint();
      msg.textContent=''; msg.className='msg';
    }else{
      clearRects();
    }
    undoStack.length = 0; setUndoState();
  });
  checkBtn.addEventListener('click', ()=>{ checkAnswer(); updateFractionHint(); });
  randomBtn.addEventListener('click', ()=>{
    const Ns = [8,12,16]; numSel.value = Ns[Math.floor(Math.random()*Ns.length)]; setup();
  });
  numSel.addEventListener('change', setup);
  peopleSel.addEventListener('change', ()=>{ buildTrays(parseInt(peopleSel.value,10)); layoutTrayContents(); updateCounts(); updateFractionHint(); });

  // かこい用の描画イベント
  stage.addEventListener('mousedown', e=>{ if(currentMode()==='enclose' && drawMode) startDraw(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e=>{ if(currentMode()==='enclose' && drawMode) moveDraw(e.clientX, e.clientY); });
  window.addEventListener('mouseup', e=>{ if(currentMode()==='enclose' && drawMode) endDraw(); });
  stage.addEventListener('touchstart', e=>{ if(currentMode()==='enclose' && drawMode){ const t=e.touches[0]; startDraw(t.clientX,t.clientY); e.preventDefault(); }},{passive:false});
  stage.addEventListener('touchmove', e=>{ if(currentMode()==='enclose' && drawMode){ const t=e.touches[0]; moveDraw(t.clientX,t.clientY); e.preventDefault(); }},{passive:false});
  stage.addEventListener('touchend', e=>{ if(currentMode()==='enclose' && drawMode){ endDraw(); e.preventDefault(); }},{passive:false});

  function setup(){
    const total = parseInt(numSel.value,10);
    setTimeout(()=>{
      layoutSnacks(total);
      buildTrays(parseInt(peopleSel.value,10));
      clearRects();
      layoutTrayContents();
      updateCounts();
      updateFractionHint();
      drawMode = false; drawBtn.textContent='分ける（しかくをかく）'; drawBtn.classList.add('hide');
    }, 0);
  }
  setup();
})();
</script>
</body>
</html>
