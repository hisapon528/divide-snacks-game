<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>おかし分けゲーム</title>
<style>
  :root{
    --bg:#f8fafc; --ink:#0f172a; --muted:#64748b; --good:#16a34a; --bad:#ef4444; --card:#fff; --grid:#e5e7eb; --accent:#2563eb;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "BIZ UDPGothic","Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; color:var(--ink); background:var(--bg);}
  .wrap{max-width:980px; margin:0 auto; padding:16px}
  .card{background:var(--card); border-radius:18px; box-shadow:0 8px 24px rgba(0,0,0,.06); padding:16px;}
  h1{margin:4px 0 10px; font-size:clamp(18px,2.6vw,28px)}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .pill{border:1px solid var(--grid); padding:6px 10px; border-radius:999px; background:#fff}
  button{border:none; border-radius:12px; padding:9px 14px; background:#0f172a; color:#fff; cursor:pointer}
  button.ghost{background:#fff; color:#000; border:1px solid var(--grid)}
  button.good{background:var(--good)} button.bad{background:var(--bad)}
  button:disabled{opacity:.5; cursor:not-allowed}
  .area{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:10px}
  @media(min-width:840px){ .area{grid-template-columns: 2fr 3fr} }
  .board{position:relative; background:#fff; border:1px dashed var(--grid); border-radius:14px; padding:12px}
  .titleRow{display:flex; justify-content:space-between; align-items:center; margin:0 4px 6px}
  .mini{font-size:13px; color:var(--muted)}
  .stage{ position:relative; width:100%; max-width:520px; margin:0 auto; aspect-ratio: 4/3; background:#fff; border-radius:12px; border:1px solid var(--grid);}
  .snack{ position:absolute; width:58px; height:58px; border-radius:50%; 
          background:radial-gradient(circle at 35% 35%, #6b7280 10px, #111827 12px, #333 13px, #111 15px, #2b2b2b 24px, #1b1b1b 30px);
          box-shadow: inset 0 0 0 3px #0a0a0a, 0 3px 6px rgba(0,0,0,.25);
  }
  .overlay{ position:absolute; inset:0; pointer-events:none }
  .overlay svg{ width:100%; height:100%}
  .mark{ fill: rgba(37,99,235,.10); stroke:var(--accent); stroke-width:3 }
  .countLabel{ font-weight:700; fill:#1e40af }
  .msg{margin-top:8px; text-align:center; font-weight:800; font-size:18px}
  .msg.good{ color:var(--good)} .msg.bad{ color:var(--bad)}
  .counts{display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:6px}
  .tag{background:#eef2ff; color:#1e3a8a; padding:6px 10px; border-radius:999px; font-weight:700}
  .note{ font-size:14px; color:#64748b; text-align:center; margin-top:4px }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>おかし分けゲーム</h1>
    <div class="toolbar">
      <span class="pill">おかし：
        <select id="numSelect">
          <option value="8" selected>8こ</option>
          <option value="12">12こ</option>
          <option value="16">16こ</option>
        </select>
      </span>
      <button id="drawBtn">分ける</button>
      <button id="undoBtn" class="ghost" disabled>やりなおし</button>
      <button id="clearBtn" class="ghost">ぜんぶけす</button>
      <button id="checkBtn" class="good">こたえあわせ</button>
      <button id="randomBtn" class="ghost">つぎのもんだい</button>
    </div>

    <div class="area">
      <section class="board">
        <div class="titleRow">
          <strong>おかしの図</strong>
          <span class="mini">ドラッグしてかこいをかきます（分けるモード中）</span>
        </div>
        <div id="stage" class="stage" aria-label="おかしのステージ">
          <div id="snacks"></div>
          <div class="overlay" id="overlay">
            <svg id="svg"></svg>
          </div>
        </div>
        <div class="counts" id="counts"></div>
        <div class="msg" id="message" aria-live="polite"></div>
      </section>

      <section class="board">
        <div class="titleRow"><strong>学びのめあて</strong></div>
        <ul>
          <li>分けたじぶんのおかしを、分数を使ってあらわそう。</div>
        <div class="titleRow"><strong>ルール</strong></div>
          <li>かこった数をふやすほど人数がふえる。かこった中の数が「一人分」。</li>
          <li>ぜんぶで <span id="totalLabel">8</span> こ。<span id="fractionLine" class="mini"></span></li>
        </ul>
      </section>
    </div>
  </div>
</div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const snacksWrap = document.getElementById('snacks');
  const svg = document.getElementById('svg');
  const numSel = document.getElementById('numSelect');
  const drawBtn = document.getElementById('drawBtn');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const checkBtn = document.getElementById('checkBtn');
  const randomBtn = document.getElementById('randomBtn');
  const countsEl = document.getElementById('counts');
  const msg = document.getElementById('message');
  const totalLabel = document.getElementById('totalLabel');
  const fractionLine = document.getElementById('fractionLine');

  let snacks = []; // {x,y,r}
  let rects = [];  // {x,y,w,h,r, node}
  let drawMode = false;
  let drawing = null; // {startX,startY,node}
  const gridCols = 4;
  const snackSize = 58;

  function setUndoState(){
    undoBtn.disabled = rects.length === 0;
  }

  function layoutSnacks(total){
    snacksWrap.innerHTML = '';
    snacks = [];
    const rect = stage.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const colGap = (w - snackSize*gridCols) / (gridCols+1);
    const rowCount = Math.ceil(total / gridCols);
    const rowGap = (h - snackSize*rowCount) / (rowCount+1);
    let idx = 0;
    for(let r=0;r<rowCount;r++){
      for(let c=0;c<gridCols;c++){
        if(idx >= total) break;
        const x = colGap*(c+1) + snackSize*c;
        const y = rowGap*(r+1) + snackSize*r;
        const d = document.createElement('div');
        d.className='snack';
        d.style.left = x+'px'; d.style.top = y+'px';
        snacksWrap.appendChild(d);
        snacks.push({x: x + snackSize/2, y: y + snackSize/2, r: snackSize/2});
        idx++;
      }
    }
  }

  function clearRects(){
    rects = [];
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    updateCounts();
    msg.textContent = ''; msg.className = 'msg';
    updateFractionHint();
    setUndoState();
  }

  function startDraw(clientX, clientY){
    if(!drawMode) return;
    const box = stage.getBoundingClientRect();
    const x = clientX - box.left, y = clientY - box.top;
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('class','mark');
    r.setAttribute('x', x); r.setAttribute('y', y); r.setAttribute('width', 1); r.setAttribute('height', 1);
    r.setAttribute('rx', 16); r.setAttribute('ry', 16);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('class','countLabel');
    t.setAttribute('x', x+0.5); t.setAttribute('y', y+0.5);
    t.setAttribute('text-anchor','middle'); t.setAttribute('dy','.35em');
    t.textContent='';
    g.appendChild(r); g.appendChild(t); svg.appendChild(g);
    drawing = {startX:x, startY:y, node:g};
  }
  function moveDraw(clientX, clientY){
    if(!drawing) return;
    const box = stage.getBoundingClientRect();
    const x = clientX - box.left, y = clientY - box.top;
    const x1 = Math.min(drawing.startX, x), y1 = Math.min(drawing.startY, y);
    const w = Math.abs(x - drawing.startX), h = Math.abs(y - drawing.startY);
    const rr = drawing.node.querySelector('rect');
    const t = drawing.node.querySelector('text');
    rr.setAttribute('x', x1); rr.setAttribute('y', y1); rr.setAttribute('width', w); rr.setAttribute('height', h);
    t.setAttribute('x', x1 + w/2); t.setAttribute('y', y1 + h/2);
  }

  // 点が角丸長方形に含まれるか
  function pointInRoundRect(px, py, rect){
    const {x,y,w,h,r} = rect;
    if (w<=0 || h<=0) return false;
    const rx = Math.min(r, w/2), ry = Math.min(r, h/2);
    if (px >= x+rx && px <= x+w-rx && py >= y && py <= y+h) return true;
    if (py >= y+ry && py <= y+h-ry && px >= x && px <= x+w) return true;
    const c1 = {cx:x+rx, cy:y+ry};
    const c2 = {cx:x+w-rx, cy:y+ry};
    const c3 = {cx:x+rx, cy:y+h-ry};
    const c4 = {cx:x+w-rx, cy:y+h-ry};
    const inCircle = (cx,cy)=> (px-cx)*(px-cx) + (py-cy)*(py-cy) <= Math.min(rx,ry)*Math.min(rx,ry);
    if(px < x+rx && py < y+ry) return inCircle(c1.cx,c1.cy);
    if(px > x+w-rx && py < y+ry) return inCircle(c2.cx,c2.cy);
    if(px < x+rx && py > y+h-ry) return inCircle(c3.cx,c3.cy);
    if(px > x+w-rx && py > y+h-ry) return inCircle(c4.cx,c4.cy);
    return false;
  }

  function countSnacksIn(rect){
    let cnt = 0;
    snacks.forEach(s=>{ if(pointInRoundRect(s.x, s.y, rect)) cnt++; });
    return cnt;
  }

  function endDraw(){
    if(!drawing) return;
    const rr = drawing.node.querySelector('rect');
    const x = parseFloat(rr.getAttribute('x'));
    const y = parseFloat(rr.getAttribute('y'));
    const w = Math.max(12, parseFloat(rr.getAttribute('width')));
    const h = Math.max(12, parseFloat(rr.getAttribute('height')));
    const r = parseFloat(rr.getAttribute('rx')) || 16;
    rr.setAttribute('width', w); rr.setAttribute('height', h);
    const temp = {x,y,w,h,r,node:drawing.node};
    // 中におかしが無ければ描画しない（人数にも数えない）
    const inside = countSnacksIn(temp);
    if(inside === 0){
      if (temp.node && temp.node.parentNode) temp.node.parentNode.removeChild(temp.node);
      msg.textContent = 'かこった中におかしがありません。';
      msg.className = 'msg';
    }else{
      rects.push(temp);
    }
    drawing = null;
    updateCounts();
    updateFractionHint();
    setUndoState();
  }

  function computeAssignments(){
    const belong = snacks.map(()=> -1);
    let overlap = false;
    rects.forEach((rc, ri)=>{
      snacks.forEach((s, si)=>{
        if(pointInRoundRect(s.x, s.y, rc)){
          if(belong[si] !== -1) overlap = true;
          belong[si] = ri;
        }
      });
    });
    return {belong, overlap};
  }

  function updateCounts(){
    const {belong, overlap} = computeAssignments();
    const per = rects.map(()=>0);
    belong.forEach(ri => { if(ri>=0) per[ri]++; });

    rects.forEach((rc, i)=>{
      const t = rc.node.querySelector('text');
      t.textContent = per[i] ? per[i]+'こ' : '';
    });

    countsEl.innerHTML = '';
    per.forEach((n,i)=>{
      const tag = document.createElement('div');
      tag.className='tag'; tag.textContent = `かこい${i+1}：${n}こ`; countsEl.appendChild(tag);
    });
    const unassigned = belong.filter(v=>v===-1).length;
    const tag = document.createElement('div');
    tag.className='tag'; tag.textContent = `のこり：${unassigned}こ`; countsEl.appendChild(tag);

    msg.textContent = overlap ? '同じおかしを分けています（重なり）' : msg.textContent;
    msg.className = overlap ? 'msg bad' : msg.className;
  }

  function checkAnswer(){
    const total = snacks.length;
    if(rects.length === 0){
      msg.textContent = 'おかしをかこって、同じ数にわけよう。'; msg.className = 'msg bad'; return;
    }
    const {belong, overlap} = computeAssignments();
    if(overlap){ msg.textContent = '同じおかしを分けています（重なり）。'; msg.className = 'msg bad'; return; }
    const perCounts = rects.map(()=>0);
    belong.forEach(ri => { if(ri>=0) perCounts[ri]++; });
    const unassigned = belong.filter(v=>v===-1).length;
    if(unassigned > 0){ msg.textContent = 'ぜんぶのおかしが 分けられていません。'; msg.className = 'msg bad'; return; }
    const first = perCounts[0];
    const allEqual = perCounts.every(n => n === first);
    if(!allEqual){ msg.textContent = 'どのかこいも 同じ数に なるように分けよう。'; msg.className = 'msg bad'; return; }
    msg.textContent = `せいかい！ 人数：${rects.length}人 ／ 1人分：${first}こ`; msg.className = 'msg good';
    fractionLine.textContent = `（${total}この 1/${rects.length} は ${first}こ）`;
  }

  function updateFractionHint(){
    const total = snacks.length; totalLabel.textContent = total;
    if([2,4].includes(rects.length) && Number.isInteger(total / rects.length)){
      fractionLine.textContent = `ヒント： ${total}この 1/${rects.length} は ${total/rects.length}こ`;
    }else{ fractionLine.textContent = ''; }
  }

  // UI
  drawBtn.addEventListener('click', ()=>{
    drawMode = !drawMode;
    drawBtn.textContent = drawMode ? '分ける（分けるモード中）' : '分ける（かこいをかく）';
    drawBtn.classList.toggle('ghost', !drawMode);
  });
  undoBtn.addEventListener('click', ()=>{
    if(rects.length === 0) return;
    const last = rects.pop();
    if(last.node && last.node.parentNode) last.node.parentNode.removeChild(last.node);
    updateCounts();
    updateFractionHint();
    setUndoState();
  });
  clearBtn.addEventListener('click', clearRects);
  checkBtn.addEventListener('click', ()=>{ checkAnswer(); updateFractionHint(); });
  randomBtn.addEventListener('click', ()=>{
    const Ns = [8,12,16]; numSel.value = Ns[Math.floor(Math.random()*Ns.length)]; setup();
  });
  numSel.addEventListener('change', setup);

  // ★描画イベント
  stage.addEventListener('mousedown', e=>{ if(drawMode) startDraw(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e=>{ if(drawMode) moveDraw(e.clientX, e.clientY); });
  window.addEventListener('mouseup', e=>{ if(drawMode) endDraw(); });

  stage.addEventListener('touchstart', e=>{ if(drawMode){ const t=e.touches[0]; startDraw(t.clientX,t.clientY); e.preventDefault(); }},{passive:false});
  stage.addEventListener('touchmove', e=>{ if(drawMode){ const t=e.touches[0]; moveDraw(t.clientX,t.clientY); e.preventDefault(); }},{passive:false});
  stage.addEventListener('touchend', e=>{ if(drawMode){ endDraw(); e.preventDefault(); }},{passive:false});

  function setup(){
    const total = parseInt(numSel.value,10);
    setTimeout(()=>{ layoutSnacks(total); clearRects(); updateFractionHint(); }, 0);
  }
  setup();
})();
</script>
</body>
</html>
